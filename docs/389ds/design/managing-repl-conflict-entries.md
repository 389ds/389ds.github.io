---
title: "Managing Replication Conflict Entries"
---

# Managing Replication Conflict Entries
------------------

{% include toc.md %}

Overview
========

In multimaster replication the same entry (entries with the same DN), can be added concurrently and will be accepted by the masters whhic handle the ADD. After replication there would be two entries with the same DN, which violates the LDAP data model. So replication needs to “resolve this conflict.

Note: the entries with the same dn could be really different entries, or, the most likely case, the same entry just sent concurrently to two masters. But even in the latter case the entries will be different to some degree: they have different nsuniqueids assigned and attributes generated by plugins could differ.

Current solution
================

In the current implementation conflict resolution one of the entries is transformed into a “conflict entry”, this is the same entry with a modified DN: DN=nsuniqueid+<current rdn>,<current parent dn>
The decision which entry is transformed is based on the CSN when the entry was created, so the result of conflict resolution will be the same on all masters.

Problems with current solution
==============================

## Multiple entries with same attributes
If an entry with eg uid=xxxx is resulting in a conflict, then a saerch for “uid=xxxx” will return both entries and clients expecting one entry can fail

## Inconsistent data 
In scenarios where the same entry is added concurrently on three masters and deleted on one master, depending on the timing of teh adds and deletes and the  order in which they are replicated there will be inconsistent representations of “normal” and “conflict” entries on the different masters.

Suggested solutions
===================
Currently there are two suggested solutions to improve handling of conflict entries, but both only address the problem of multiple visible entries, but not the inconsistency problem.
The proposal is to hide the conflict entries, either by
	adding an objectclass ldapsubentry so that the entries will not be returned in normal searches
	putting conflict entries into a separate suffix

This hiding approach does not work in all scenarios
	if the two conflicting entries have different children, the conflicting entry will remain visible in one child
	the inconsistency case will only show different inconsistencies, if in the current implemetation on one master a conflict entry is visible and on others a normal then after hiding the conflict on one master no entry will be visible and on the other a normal one.
	Hiding does not help to prevent the inconsistencies, since replication identifies the entry to operate on by the nsuniqueid of the entry original modified/deleted 

Proposal: manage conflict entries in one entry
==============================================
Instead of creating new entries in the conflict case, the conflict could be represented by operational attributes in the “winning” entry. This would avoid multiple entries, it would be invisible to clients if not explicitely requested, and the inconsistencies would disappear – to be verified.

## Conflict representation 

decide which entry will become the main entry

add attribute to track the other nsuniqueid

add attributes for all (only the differing) attributes of the conflicting entry, tagged by the nsuniqueid 

Example: Assume there are two entries:

       dn: cn=user1,dc=example,dc=com
       [ addcsn: t0]
       objectclass: person
       sn: One
       uid: 100001
       nsuniqueid: 1111111-1111111-1111111-1111111

and 

       dn: cn=user1,dc=example,dc=com
       [ addcsn: t1]
       objectclass: person
       sn: One
       uid: 200001
       nsuniqueid: 2222222-22222222-22222222-22222222

after concflict resolution this will become:

       dn: cn=user1,dc=example,dc=com
       [ addcsn: t0]
       objectclass: person
       sn: One
       uid: 100001
       nsuniqueid: 1111111-1111111-1111111-1111111
       conflictnsuniquid: 2222222-22222222-22222222-22222222
       conflictattr;2222222-22222222-22222222-22222222;uid: 200001
       [conflictattr;2222222-22222222-22222222-22222222;objectclass: person]
       [conflictattr;2222222-22222222-22222222-22222222;sn: One]

In a replication operation, the nsuniqueid of the original entry is used to find the entry. If no entyr with this uniqueid exists, an entry with conflictnsuniqueid is looked up.

## Behaviour in inconsistency scenarios

## Deleting entries

One problem with this approach is that more than one entry are merged into one, this is necessary to avoid inconsistencies during replication. But if an entry with a conflictnsuniqueid is deleted by a direct ldap operation, 
the complete entry should be deleted ann not only the "main" nsuniqueid". This requires to split the change for replication operations into two (or more) deletes - one for each uniqueids.
On the replication consumer the behaviour is a as in the "inconsistency avoidance", the traces for the deleted nsuniqueid are removed. The entry is finally removed after applying the delete for the last nsuniqueid


Tickets
=======
* Ticket [\#160](https://fedorahosted.org/389/ticket/160) - Make replication plugin put conflicts and tombstones in a special suffix
* Ticket [\#47432](https://fedorahosted.org/389/ticket/47432) conflict leaves unconsistent entries
* Ticket [\#48161](https://fedorahosted.org/389/ticket/48161) RFE: it could be nice to have replication conflicts being skipped in client app queries
